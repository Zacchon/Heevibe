<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beehive Simulator</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #87CEEB 0%, #98FB98 100%);
            min-height: 100vh;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        .controls {
            background: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .controls button {
            background: #FFA500;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
        }
        
        .controls button:hover {
            background: #FF8C00;
        }
        
        .controls button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .info-panel {
            background: rgba(255, 255, 255, 0.9);
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
            font-size: 14px;
        }
        
        canvas {
            border: 3px solid #8B4513;
            border-radius: 10px;
            background: #E6F3FF;
            box-shadow: 0 4px 20px rgba(0,0,0,0.2);
            display: block;
            margin: 0 auto;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üêù Interactive Beehive Simulator</h1>
        
        <div class="controls">
            <button id="playPause">‚è∏Ô∏è Pause</button>
            <button id="addFlowers">üå∏ Add Flowers</button>
            <button id="addBees">üêù Add Bees</button>
            <button id="reset">üîÑ Reset</button>
            <label>
                Speed: <input type="range" id="speedSlider" min="0.1" max="3" step="0.1" value="1">
            </label>
        </div>
        
        <canvas id="canvas" width="1000" height="600"></canvas>
        
        <div class="info-panel">
            <div id="stats">
                Bees: <span id="beeCount">0</span> | 
                Flowers: <span id="flowerCount">0</span> | 
                Nectar Collected: <span id="nectarCount">0</span> | 
                Active Foragers: <span id="foragerCount">0</span>
            </div>
        </div>
    </div>

    <script>
        class Vector2 {
            constructor(x = 0, y = 0) {
                this.x = x;
                this.y = y;
            }
            
            add(other) {
                return new Vector2(this.x + other.x, this.y + other.y);
            }
            
            subtract(other) {
                return new Vector2(this.x - other.x, this.y - other.y);
            }
            
            multiply(scalar) {
                return new Vector2(this.x * scalar, this.y * scalar);
            }
            
            normalize() {
                const mag = this.magnitude();
                if (mag === 0) return new Vector2(0, 0);
                return new Vector2(this.x / mag, this.y / mag);
            }
            
            magnitude() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }
            
            distance(other) {
                return this.subtract(other).magnitude();
            }
        }

        class Bee {
            constructor(x, y, hive) {
                this.position = new Vector2(x, y);
                this.velocity = new Vector2(0, 0);
                this.hive = hive;
                this.state = 'exploring'; // 'exploring', 'foraging', 'returning', 'dancing'
                this.target = null;
                this.nectar = 0;
                this.maxNectar = 3;
                this.speed = 1 + Math.random() * 0.5;
                this.energy = 100;
                this.danceTimer = 0;
                this.flowerMemory = null;
                this.id = Math.random().toString(36).substr(2, 9);
                this.wanderAngle = Math.random() * Math.PI * 2;
                this.stateTimer = 0;
                this.color = this.getColorForState();
            }
            
            getColorForState() {
                switch(this.state) {
                    case 'exploring': return '#FFD700';
                    case 'foraging': return '#FFA500';
                    case 'returning': return '#FF6B35';
                    case 'dancing': return '#FF1493';
                    default: return '#FFD700';
                }
            }
            
            update(deltaTime, flowers) {
                this.stateTimer += deltaTime;
                this.color = this.getColorForState();
                
                switch(this.state) {
                    case 'exploring':
                        this.explore(flowers);
                        break;
                    case 'foraging':
                        this.forage(flowers);
                        break;
                    case 'returning':
                        this.returnToHive();
                        break;
                    case 'dancing':
                        this.dance();
                        break;
                }
                
                this.move(deltaTime);
                this.energy = Math.max(0, this.energy - deltaTime * 0.1);
            }
            
            explore(flowers) {
                // Look for flowers
                const nearbyFlowers = flowers.filter(f => 
                    f.nectar > 0 && this.position.distance(f.position) < 100
                );
                
                if (nearbyFlowers.length > 0) {
                    this.target = nearbyFlowers[0];
                    this.state = 'foraging';
                    return;
                }
                
                // Wander behavior
                this.wanderAngle += (Math.random() - 0.5) * 0.3;
                const wanderDirection = new Vector2(
                    Math.cos(this.wanderAngle),
                    Math.sin(this.wanderAngle)
                );
                
                this.velocity = wanderDirection.multiply(this.speed);
                
                // Avoid edges
                const margin = 50;
                if (this.position.x < margin) this.velocity.x = Math.abs(this.velocity.x);
                if (this.position.x > canvas.width - margin) this.velocity.x = -Math.abs(this.velocity.x);
                if (this.position.y < margin) this.velocity.y = Math.abs(this.velocity.y);
                if (this.position.y > canvas.height - margin) this.velocity.y = -Math.abs(this.velocity.y);
            }
            
            forage(flowers) {
                if (!this.target || this.target.nectar <= 0) {
                    this.state = 'exploring';
                    this.target = null;
                    return;
                }
                
                const distance = this.position.distance(this.target.position);
                
                if (distance < 15) {
                    // Collect nectar
                    const collected = Math.min(this.target.nectar, this.maxNectar - this.nectar);
                    this.nectar += collected;
                    this.target.nectar -= collected;
                    this.flowerMemory = {
                        position: this.target.position,
                        quality: this.target.nectar
                    };
                    
                    if (this.nectar >= this.maxNectar) {
                        this.state = 'returning';
                        this.target = null;
                        simulator.nectarCollected += this.nectar;
                    }
                } else {
                    // Move toward flower
                    const direction = this.target.position.subtract(this.position).normalize();
                    this.velocity = direction.multiply(this.speed);
                }
            }
            
            returnToHive() {
                const distance = this.position.distance(this.hive.position);
                
                if (distance < 30) {
                    this.nectar = 0;
                    if (this.flowerMemory && this.flowerMemory.quality > 2) {
                        this.state = 'dancing';
                        this.danceTimer = 2000; // Dance for 2 seconds
                    } else {
                        this.state = 'exploring';
                    }
                } else {
                    const direction = this.hive.position.subtract(this.position).normalize();
                    this.velocity = direction.multiply(this.speed * 1.2);
                }
            }
            
            dance() {
                this.danceTimer -= 16; // Assuming ~60fps
                
                if (this.danceTimer <= 0) {
                    this.state = 'exploring';
                    this.flowerMemory = null;
                } else {
                    // Dance movement (figure-8 pattern)
                    const dancePhase = (2000 - this.danceTimer) / 200;
                    this.position.x = this.hive.position.x + Math.sin(dancePhase) * 20;
                    this.position.y = this.hive.position.y + Math.cos(dancePhase * 2) * 10;
                }
            }
            
            move(deltaTime) {
                this.position = this.position.add(this.velocity.multiply(deltaTime));
                
                // Keep within bounds
                this.position.x = Math.max(10, Math.min(canvas.width - 10, this.position.x));
                this.position.y = Math.max(10, Math.min(canvas.height - 10, this.position.y));
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                
                // Bee body
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.ellipse(0, 0, 6, 4, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Stripes
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                for (let i = -3; i <= 3; i += 2) {
                    ctx.beginPath();
                    ctx.moveTo(i, -3);
                    ctx.lineTo(i, 3);
                    ctx.stroke();
                }
                
                // Wings
                ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                ctx.beginPath();
                ctx.ellipse(-2, -2, 4, 2, -0.3, 0, Math.PI * 2);
                ctx.fill();
                ctx.beginPath();
                ctx.ellipse(-2, 2, 4, 2, 0.3, 0, Math.PI * 2);
                ctx.fill();
                
                // Nectar indicator
                if (this.nectar > 0) {
                    ctx.fillStyle = '#FFD700';
                    ctx.beginPath();
                    ctx.arc(0, 0, 2 + this.nectar, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                ctx.restore();
            }
        }

        class Flower {
            constructor(x, y) {
                this.position = new Vector2(x, y);
                this.nectar = 5 + Math.random() * 10;
                this.maxNectar = this.nectar;
                this.regenRate = 0.1;
                this.color = this.getColorForNectar();
                this.size = 8 + Math.random() * 4;
                this.petalCount = 5 + Math.floor(Math.random() * 3);
            }
            
            getColorForNectar() {
                const intensity = this.nectar / this.maxNectar;
                const r = Math.floor(255 * intensity);
                const g = Math.floor(100 + 155 * intensity);
                const b = Math.floor(150 + 105 * intensity);
                return `rgb(${r}, ${g}, ${b})`;
            }
            
            update(deltaTime) {
                if (this.nectar < this.maxNectar) {
                    this.nectar = Math.min(this.maxNectar, this.nectar + this.regenRate * deltaTime);
                }
                this.color = this.getColorForNectar();
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                
                // Stem
                ctx.strokeStyle = '#228B22';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(0, this.size);
                ctx.lineTo(0, this.size + 20);
                ctx.stroke();
                
                // Petals
                ctx.fillStyle = this.color;
                for (let i = 0; i < this.petalCount; i++) {
                    const angle = (i / this.petalCount) * Math.PI * 2;
                    const petalX = Math.cos(angle) * this.size;
                    const petalY = Math.sin(angle) * this.size;
                    
                    ctx.beginPath();
                    ctx.ellipse(petalX, petalY, this.size * 0.6, this.size * 0.3, angle, 0, Math.PI * 2);
                    ctx.fill();
                }
                
                // Center
                ctx.fillStyle = '#FFA500';
                ctx.beginPath();
                ctx.arc(0, 0, this.size * 0.4, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.restore();
            }
        }

        class Hive {
            constructor(x, y) {
                this.position = new Vector2(x, y);
                this.size = 40;
            }
            
            draw(ctx) {
                ctx.save();
                ctx.translate(this.position.x, this.position.y);
                
                // Hive body
                ctx.fillStyle = '#8B4513';
                ctx.beginPath();
                ctx.ellipse(0, 0, this.size, this.size * 0.8, 0, 0, Math.PI * 2);
                ctx.fill();
                
                // Entrance
                ctx.fillStyle = '#654321';
                ctx.beginPath();
                ctx.arc(0, this.size * 0.5, 8, 0, Math.PI * 2);
                ctx.fill();
                
                // Texture lines
                ctx.strokeStyle = '#654321';
                ctx.lineWidth = 2;
                for (let i = -2; i <= 2; i++) {
                    ctx.beginPath();
                    ctx.moveTo(-this.size * 0.8, i * 8);
                    ctx.lineTo(this.size * 0.8, i * 8);
                    ctx.stroke();
                }
                
                ctx.restore();
            }
        }

        class BeeSimulator {
            constructor() {
                this.canvas = document.getElementById('canvas');
                this.ctx = this.canvas.getContext('2d');
                this.bees = [];
                this.flowers = [];
                this.hive = new Hive(150, 300);
                this.isRunning = true;
                this.speed = 1;
                this.nectarCollected = 0;
                this.lastTime = 0;
                
                this.initializeSimulation();
                this.setupEventListeners();
                this.animate();
            }
            
            initializeSimulation() {
                // Create initial bees
                for (let i = 0; i < 15; i++) {
                    this.addBee();
                }
                
                // Create initial flowers
                for (let i = 0; i < 10; i++) {
                    this.addFlower();
                }
            }
            
            addBee() {
                const angle = Math.random() * Math.PI * 2;
                const distance = 20 + Math.random() * 30;
                const x = this.hive.position.x + Math.cos(angle) * distance;
                const y = this.hive.position.y + Math.sin(angle) * distance;
                this.bees.push(new Bee(x, y, this.hive));
            }
            
            addFlower() {
                const x = 100 + Math.random() * (this.canvas.width - 200);
                const y = 100 + Math.random() * (this.canvas.height - 200);
                this.flowers.push(new Flower(x, y));
            }
            
            setupEventListeners() {
                document.getElementById('playPause').addEventListener('click', () => {
                    this.isRunning = !this.isRunning;
                    document.getElementById('playPause').textContent = this.isRunning ? '‚è∏Ô∏è Pause' : '‚ñ∂Ô∏è Play';
                });
                
                document.getElementById('addFlowers').addEventListener('click', () => {
                    for (let i = 0; i < 3; i++) {
                        this.addFlower();
                    }
                });
                
                document.getElementById('addBees').addEventListener('click', () => {
                    for (let i = 0; i < 5; i++) {
                        this.addBee();
                    }
                });
                
                document.getElementById('reset').addEventListener('click', () => {
                    this.bees = [];
                    this.flowers = [];
                    this.nectarCollected = 0;
                    this.initializeSimulation();
                });
                
                document.getElementById('speedSlider').addEventListener('input', (e) => {
                    this.speed = parseFloat(e.target.value);
                });
                
                // Click to add flowers
                this.canvas.addEventListener('click', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;
                    this.flowers.push(new Flower(x, y));
                });
            }
            
            update(deltaTime) {
                if (!this.isRunning) return;
                
                const adjustedDeltaTime = deltaTime * this.speed;
                
                // Update bees
                this.bees.forEach(bee => {
                    bee.update(adjustedDeltaTime, this.flowers);
                });
                
                // Update flowers
                this.flowers.forEach(flower => {
                    flower.update(adjustedDeltaTime);
                });
                
                // Update stats
                this.updateStats();
            }
            
            updateStats() {
                document.getElementById('beeCount').textContent = this.bees.length;
                document.getElementById('flowerCount').textContent = this.flowers.length;
                document.getElementById('nectarCount').textContent = Math.floor(this.nectarCollected);
                document.getElementById('foragerCount').textContent = 
                    this.bees.filter(bee => bee.state === 'foraging' || bee.state === 'returning').length;
            }
            
            draw() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw background elements
                this.drawEnvironment();
                
                // Draw hive
                this.hive.draw(this.ctx);
                
                // Draw flowers
                this.flowers.forEach(flower => {
                    flower.draw(this.ctx);
                });
                
                // Draw bees
                this.bees.forEach(bee => {
                    bee.draw(this.ctx);
                });
                
                // Draw dance indicators
                this.drawDanceIndicators();
            }
            
            drawEnvironment() {
                // Draw grass
                this.ctx.fillStyle = '#90EE90';
                this.ctx.fillRect(0, this.canvas.height - 50, this.canvas.width, 50);
                
                // Draw sky gradient
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.canvas.height);
                gradient.addColorStop(0, '#87CEEB');
                gradient.addColorStop(1, '#E0F6FF');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height - 50);
            }
            
            drawDanceIndicators() {
                const dancingBees = this.bees.filter(bee => bee.state === 'dancing');
                
                dancingBees.forEach(bee => {
                    if (bee.flowerMemory) {
                        // Draw line to flower location
                        this.ctx.strokeStyle = 'rgba(255, 20, 147, 0.5)';
                        this.ctx.lineWidth = 2;
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.beginPath();
                        this.ctx.moveTo(bee.position.x, bee.position.y);
                        this.ctx.lineTo(bee.flowerMemory.position.x, bee.flowerMemory.position.y);
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                    }
                    
                    // Draw dance circle
                    this.ctx.strokeStyle = 'rgba(255, 20, 147, 0.8)';
                    this.ctx.lineWidth = 3;
                    this.ctx.beginPath();
                    this.ctx.arc(bee.position.x, bee.position.y, 25, 0, Math.PI * 2);
                    this.ctx.stroke();
                });
            }
            
            animate(currentTime = 0) {
                const deltaTime = currentTime - this.lastTime;
                this.lastTime = currentTime;
                
                this.update(deltaTime);
                this.draw();
                
                requestAnimationFrame((time) => this.animate(time));
            }
        }

        // Initialize the simulator
        const simulator = new BeeSimulator();
    </script>
</body>
</html>